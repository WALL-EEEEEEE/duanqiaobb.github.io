
---
title: "算法-翻转数列"
date: 2018-11-25 17:41:35 +0000 UTC
description: "翻转数列小Q定义了一种数列称为翻转数列:给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4..., 每隔m个符号翻转一次, 最初符号为'-';。例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.小Q现在希望你能帮他算算前n项和为..."
---
### 翻转数列

```
小Q定义了一种数列称为翻转数列:
给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4..., 每隔m个符号翻转一次, 最初符号为'-';。
例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.
而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.
小Q现在希望你能帮他算算前n项和为多少。

输入描述:
输入包括两个整数n和m(2 <= n <= 109, 1 <= m), 并且满足n能被2m整除。

输出描述:
输出一个整数, 表示前n项和。

输入例子1:
 8 2

输出例子1:
 8
```
+ 思路

```
1. n能被2m整除，我们可以得出, n 为2m的整数倍，
2. 根据数列的规律，2m个元素的和为m^2
所以我们可以把n个元素划分为多个2m元素组成的块，x = n/(2*m),
那么前n项的和可以看作这些块的总和：S_n = x*m^2 = n/(2*m)*m^2 = n/2 * m
```

+ 算法复杂度

&ensp;&ensp;&ensp;&ensp;算法的平均复杂度: O(n) = 1; 最坏情况下的复杂度为：O(n) = 1。

#### cpp实现

```cpp
#include <iostream>
using namespace std;
long sumn_reverse_permutation(int n, int m) {
    if ( n < 2 || n > 1000000000 || m < 1 || n % (2*m) != 0 ) {
        return -1;
    }
    long num_2m = n / (2*m);
    long sum_n = num_2m * m * m;
    return sum_n;
}
int main(int argc, char** argv) {
    int n, m;
    scanf("%d %d",&n, &m);
    long sum_n = sumn_reverse_permutation(n,m);
    cout << sum_n << endl;
} 
```

> **Note:** 注意c++的`int`类型表示的数值范围为：0~2^32次方，无法表示最后的存储结果，同时如果计算的时候都是`int`类型的话，编译器不会自动将类型转换为`long`类型，需要将计算时的其中一个元素定义为`long`类型，然后计算结果也存储为`long`类型。

