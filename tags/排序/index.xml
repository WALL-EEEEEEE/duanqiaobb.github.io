<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>排序 on 断桥bian的博客</title>
    <link>/tags/%E6%8E%92%E5%BA%8F/</link>
    <description>Recent content in 排序 on 断桥bian的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 18 Dec 2018 17:11:43 +0000</lastBuildDate><atom:link href="/tags/%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法-堆排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-12-18-%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 18 Dec 2018 17:11:43 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-12-18-%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>堆排序思路将数组转换成一个最小堆（升序排序）/最大堆（降序排序），然后挨个删除并输出堆顶元素，并继续调整堆为最小堆（升序排序）或者 最大堆（降序排列），从而最终生成一个升序或者降序序列。算法复杂度平均复杂度为:  O(n) = nlogn，最坏情况下的算法复杂度：O(n) = nlogn;python实现## HeapSort implemented by pytho...</description>
    </item>
    
    <item>
      <title>算法-归并排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-12-10-%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 10 Dec 2018 21:31:34 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-12-10-%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>归并排序思路归并排序采用的是分治的思想，将一个 n 长度的数组不断的分成无数个小数组，然后对小数组进行排序，最后将所以的有序小数组合并，最终数组有序。算法复杂度    归并排序的平均复杂度： O(n) = nlogn, 最坏时间复杂度为：O(n) = nlogn算法空间复杂度    归并排序的空间复杂度： O(n) = npython实现# 递归实现import ...</description>
    </item>
    
    <item>
      <title>算法-插入排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-12-09-%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 09 Dec 2018 22:39:02 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-12-09-%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>插入排序思路插入排序是最直观和自然的排序，它是从左到右，将一个数从它为起始位置 loc ，从右向左，进行比较，如果 array[loc-1] &amp;amp;lt; array[loc] 或者 loc = 0 ，那么就将这个数插入 loc 位置，否则 loc 位置左移 ( loc = loc -1 )继续进行比较，直到数组有序。算法复杂度    插入排序的最坏时间复杂度为: O(n) = ...</description>
    </item>
    
    <item>
      <title>算法-冒泡排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-12-09-%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 09 Dec 2018 21:34:54 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-12-09-%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>冒泡排序思路模拟水中的冒泡过程, 大的水泡总是从底部不断的超过小的水泡，最终上升到水面。冒泡排序也是，从左到右,小的数不断的从右边冒泡上升到左边，最终实现有序。复杂度    冒泡排序的最坏时间复杂度为: O(n) = n^2，平均复杂度为： O(n) = n^2python实现def bubblesort(arr):    for i in range(0,len(arr...</description>
    </item>
    
    <item>
      <title>算法-  快速排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 25 Nov 2018 16:19:00 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>快速排序思路选定一个pivot, 移动元素使得pivot左右两边的元素，一边大于pivot, 一边小于pivot, 然后分别对左右两边递归进行同样的操作，最后得到一个有序排列。复杂度    快速排序的最坏时间复杂度为: O(n) = n^2，但平均复杂度为： O(n) = nlogncpp实现template &amp;amp;lt;class Type&amp;amp;gt;void Swap(...</description>
    </item>
    
  </channel>
</rss>
