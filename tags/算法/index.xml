<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>算法 on 断桥bian的博客</title>
    <link>/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 断桥bian的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 18 Dec 2018 17:11:43 +0000</lastBuildDate><atom:link href="/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法-堆排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-12-18-%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 18 Dec 2018 17:11:43 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-12-18-%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>堆排序思路将数组转换成一个最小堆（升序排序）/最大堆（降序排序），然后挨个删除并输出堆顶元素，并继续调整堆为最小堆（升序排序）或者 最大堆（降序排列），从而最终生成一个升序或者降序序列。算法复杂度平均复杂度为:  O(n) = nlogn，最坏情况下的算法复杂度：O(n) = nlogn;python实现## HeapSort implemented by pytho...</description>
    </item>
    
    <item>
      <title>算法-归并排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-12-10-%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 10 Dec 2018 21:31:34 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-12-10-%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>归并排序思路归并排序采用的是分治的思想，将一个 n 长度的数组不断的分成无数个小数组，然后对小数组进行排序，最后将所以的有序小数组合并，最终数组有序。算法复杂度    归并排序的平均复杂度： O(n) = nlogn, 最坏时间复杂度为：O(n) = nlogn算法空间复杂度    归并排序的空间复杂度： O(n) = npython实现# 递归实现import ...</description>
    </item>
    
    <item>
      <title>算法-插入排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-12-09-%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 09 Dec 2018 22:39:02 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-12-09-%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>插入排序思路插入排序是最直观和自然的排序，它是从左到右，将一个数从它为起始位置 loc ，从右向左，进行比较，如果 array[loc-1] &amp;amp;lt; array[loc] 或者 loc = 0 ，那么就将这个数插入 loc 位置，否则 loc 位置左移 ( loc = loc -1 )继续进行比较，直到数组有序。算法复杂度    插入排序的最坏时间复杂度为: O(n) = ...</description>
    </item>
    
    <item>
      <title>算法-冒泡排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-12-09-%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 09 Dec 2018 21:34:54 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-12-09-%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>冒泡排序思路模拟水中的冒泡过程, 大的水泡总是从底部不断的超过小的水泡，最终上升到水面。冒泡排序也是，从左到右,小的数不断的从右边冒泡上升到左边，最终实现有序。复杂度    冒泡排序的最坏时间复杂度为: O(n) = n^2，平均复杂度为： O(n) = n^2python实现def bubblesort(arr):    for i in range(0,len(arr...</description>
    </item>
    
    <item>
      <title>算法-纸牌游戏</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E7%BA%B8%E7%89%8C%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Sun, 25 Nov 2018 17:44:49 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E7%BA%B8%E7%89%8C%E6%B8%B8%E6%88%8F/</guid>
      <description>纸牌游戏时间限制：1秒空间限制：32768K牛牛和羊羊正在玩一个纸牌游戏。这个游戏一共有n张纸牌, 第i张纸牌上写着数字a_i。牛牛和羊羊轮流抽牌, 牛牛先抽, 每次抽牌他们可以从纸牌堆中任意选择一张抽出, 直到纸牌被抽完。他们的得分等于他们抽到的纸牌数字总和。现在假设牛牛和羊羊都采用最优策略, 请你计算出游戏结束后牛牛得分减去羊羊得分等于多少。输入描述:输入包括两行。第...</description>
    </item>
    
    <item>
      <title>算法-翻转数列</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E7%BF%BB%E8%BD%AC%E6%95%B0%E5%88%97/</link>
      <pubDate>Sun, 25 Nov 2018 17:41:35 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E7%BF%BB%E8%BD%AC%E6%95%B0%E5%88%97/</guid>
      <description>翻转数列小Q定义了一种数列称为翻转数列:给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4..., 每隔m个符号翻转一次, 最初符号为&amp;#39;-&amp;#39;;。例如n = 8, m = 2, 数列就是: -1, -2, &#43;3, &#43;4, -5, -6, &#43;7, &#43;8.而n = 4, m = 1, 数列就是: -1, &#43;2, -3, &#43; 4.小Q现在希望你能帮他算算前n项和为...</description>
    </item>
    
    <item>
      <title>算法-查找数组中的前M大的数</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%89%8Dm%E5%A4%A7%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sun, 25 Nov 2018 17:38:57 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%89%8Dm%E5%A4%A7%E7%9A%84%E6%95%B0/</guid>
      <description>查找数组中的前M大的数思路根据快速排序的Partition的思想，假定数组长度为n, 选定一个pivot,总能将数组分为 [0,k-1]和[k,n], 其中[0,k-1]&amp;amp;lt;pivot,[k&#43;1,n] &amp;amp;gt; pivot。如果 k = m, 那么算法结束。如果k &amp;amp;gt; m, 对[k&#43;1,n]继续进行切分,每次切分k都会减少一部分, 直到k = m, 如果k &amp;amp;lt; m, 对...</description>
    </item>
    
    <item>
      <title>算法-分块/索引查找</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E5%88%86%E5%9D%97-%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 25 Nov 2018 17:36:04 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E5%88%86%E5%9D%97-%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/</guid>
      <description>分块/索引查找思路前提： 1.块间有序 2.块内可以无序 3.索引中保存块的起始地址，和块内的最大值或者最小值   首先对索引进行折半查找，然后对块内进行顺序查找。算法复杂度    假设一个n长度的数组分为m块，每块的长度为： n/m, 那么算法的平均复杂度：O(n) = logm&#43;n/m, 算法最坏情况下的复杂度： O(n) = logm &#43; n/m。cpp实现st...</description>
    </item>
    
    <item>
      <title>算法-二分/折半查找</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 25 Nov 2018 17:33:44 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</guid>
      <description>二分/折半查找思路前提： 数组必须是已经排好序的有序数组。假设数组为升序排列，把数组一分为二，取中间点mid做比较，如果比mid大, 那么继续在[mid&#43;1,last]中查找，反之在[first,mid-1]中查找，对子数组继续进行上述操作,直到找到。算法复杂度    平均算法复杂度为： O(n) = logn；最坏情况的算法复杂度为： O(n) = logn;cpp实现...</description>
    </item>
    
    <item>
      <title>算法-顺序搜索</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sun, 25 Nov 2018 17:30:44 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2/</guid>
      <description>顺序查找思路从数组的开头到结尾,顺序挨个比较查找。算法复杂度    平均算法复杂度为：O(n)= n; 最坏情况的算法复杂度为：O(n) = n;cpp实现int orderSearch(int dest_arr[],int  dest) {    int arr_len = sizeof(dest_arr)/sizeof(*dest_arr);    for(int ...</description>
    </item>
    
    <item>
      <title>算法-  快速排序</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 25 Nov 2018 16:19:00 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>快速排序思路选定一个pivot, 移动元素使得pivot左右两边的元素，一边大于pivot, 一边小于pivot, 然后分别对左右两边递归进行同样的操作，最后得到一个有序排列。复杂度    快速排序的最坏时间复杂度为: O(n) = n^2，但平均复杂度为： O(n) = nlogncpp实现template &amp;amp;lt;class Type&amp;amp;gt;void Swap(...</description>
    </item>
    
  </channel>
</rss>
