<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>查找 on 断桥bian的博客</title>
    <link>/tags/%E6%9F%A5%E6%89%BE/</link>
    <description>Recent content in 查找 on 断桥bian的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 25 Nov 2018 17:38:57 +0000</lastBuildDate><atom:link href="/tags/%E6%9F%A5%E6%89%BE/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法-查找数组中的前M大的数</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%89%8Dm%E5%A4%A7%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sun, 25 Nov 2018 17:38:57 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%89%8Dm%E5%A4%A7%E7%9A%84%E6%95%B0/</guid>
      <description>查找数组中的前M大的数思路根据快速排序的Partition的思想，假定数组长度为n, 选定一个pivot,总能将数组分为 [0,k-1]和[k,n], 其中[0,k-1]&amp;amp;lt;pivot,[k&#43;1,n] &amp;amp;gt; pivot。如果 k = m, 那么算法结束。如果k &amp;amp;gt; m, 对[k&#43;1,n]继续进行切分,每次切分k都会减少一部分, 直到k = m, 如果k &amp;amp;lt; m, 对...</description>
    </item>
    
    <item>
      <title>算法-分块/索引查找</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E5%88%86%E5%9D%97-%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 25 Nov 2018 17:36:04 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E5%88%86%E5%9D%97-%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/</guid>
      <description>分块/索引查找思路前提： 1.块间有序 2.块内可以无序 3.索引中保存块的起始地址，和块内的最大值或者最小值   首先对索引进行折半查找，然后对块内进行顺序查找。算法复杂度    假设一个n长度的数组分为m块，每块的长度为： n/m, 那么算法的平均复杂度：O(n) = logm&#43;n/m, 算法最坏情况下的复杂度： O(n) = logm &#43; n/m。cpp实现st...</description>
    </item>
    
    <item>
      <title>算法-二分/折半查找</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 25 Nov 2018 17:33:44 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</guid>
      <description>二分/折半查找思路前提： 数组必须是已经排好序的有序数组。假设数组为升序排列，把数组一分为二，取中间点mid做比较，如果比mid大, 那么继续在[mid&#43;1,last]中查找，反之在[first,mid-1]中查找，对子数组继续进行上述操作,直到找到。算法复杂度    平均算法复杂度为： O(n) = logn；最坏情况的算法复杂度为： O(n) = logn;cpp实现...</description>
    </item>
    
    <item>
      <title>算法-顺序搜索</title>
      <link>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sun, 25 Nov 2018 17:30:44 +0000</pubDate>
      
      <guid>/blog/%E6%8A%80%E6%9C%AF/2018-11-25-%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2/</guid>
      <description>顺序查找思路从数组的开头到结尾,顺序挨个比较查找。算法复杂度    平均算法复杂度为：O(n)= n; 最坏情况的算法复杂度为：O(n) = n;cpp实现int orderSearch(int dest_arr[],int  dest) {    int arr_len = sizeof(dest_arr)/sizeof(*dest_arr);    for(int ...</description>
    </item>
    
  </channel>
</rss>
